<?xml version="1.0"?>
<doc>
    <assembly>
        <name>chia-dotnet</name>
    </assembly>
    <members>
        <member name="T:chia.dotnet.CertLoader">
            <summary>
            Helper class for loading certificates
            </summary>
        </member>
        <member name="M:chia.dotnet.CertLoader.GetCerts(System.String,System.String)">
            <summary>
            Constructs an ephemeral <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2"/> from crt and keys stored as files
            </summary>
            <param name="certPath">The full path the the .crt public cert</param>
            <param name="keyPath">The full path to the RSA encoded private key</param>
            <returns>An ephemeral certificate that can be used for WebSocket authentication</returns>
        </member>
        <member name="T:chia.dotnet.ColouredCoinWallet">
            <summary>
            Wraps a Coloured Coin wallet
            </summary>
        </member>
        <member name="M:chia.dotnet.ColouredCoinWallet.#ctor(System.UInt32,chia.dotnet.WalletProxy)">
            <summary>
            ctor
            </summary>
            <param name="walletId">The wallet_id to wrap</param>
            <param name="walletProxy">Wallet RPC proxy to use for communication</param>
        </member>
        <member name="M:chia.dotnet.ColouredCoinWallet.GetName(System.Threading.CancellationToken)">
            <summary>
            Get the name of a wallet's coloured coin
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The coin name</returns>
        </member>
        <member name="M:chia.dotnet.ColouredCoinWallet.SetName(System.String,System.Threading.CancellationToken)">
            <summary>
            Set the name of a wallet's coloured coin
            </summary>
            <param name="name">The new name</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.ColouredCoinWallet.GetColour(System.Threading.CancellationToken)">
            <summary>
            Get the colour of a wallet's coloured coin
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The colout as a string</returns>
        </member>
        <member name="M:chia.dotnet.ColouredCoinWallet.Spend(System.String,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Spend a coloured coin
            </summary>
            <param name="innerAddress">inner address for the spend</param>
            <param name="amount">the amount to put in the wallet (in units of mojos)</param> 
            <param name="fee">fee to create the wallet (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A transaction</returns>
        </member>
        <member name="T:chia.dotnet.Config">
            <summary>
            Represents a chia config yaml file and its contents. Used to find the uri and ssl certs needed to connect via a <see cref="T:System.Net.WebSockets.WebSocket"/>
            </summary>
        </member>
        <member name="P:chia.dotnet.Config.Contents">
            <summary>
            The contents of the config yaml
            </summary>
        </member>
        <member name="M:chia.dotnet.Config.GetEndpoint(System.String)">
            <summary>
            Creates an <see cref="T:chia.dotnet.EndpointInfo"/> from the named service section
            </summary>
            <param name="serviceName">The setion name in the config file. Use 'daemon' for the root config that include 'self_hostname'; i.e. the local daemon</param>
            <returns>An <see cref="T:chia.dotnet.EndpointInfo"/> that can be used to connect to the given service's RPC interface</returns>
        </member>
        <member name="P:chia.dotnet.Config.DefaultRootPath">
            <summary>
            The OS specific default location of the chia root folder (respects CHIA_ROOT)
            </summary>
        </member>
        <member name="M:chia.dotnet.Config.Open(System.String)">
            <summary>
            Opens a chia config yaml file
            </summary>
            <param name="fullPath">The full filesystem path to the config file</param>
            <returns>A <see cref="T:chia.dotnet.Config"/> instance</returns>
        </member>
        <member name="M:chia.dotnet.Config.Open">
            <summary>
            Opens the <see cref="T:chia.dotnet.Config"/> from <see cref="P:chia.dotnet.Config.DefaultRootPath"/> plus 'config' and 'config.yaml'
            </summary>
            <returns></returns>
        </member>
        <member name="T:chia.dotnet.ServiceNames">
            <summary>
            The names of chia services. These are used as <see cref="P:chia.dotnet.Message.Destination"/> values
            </summary>
        </member>
        <member name="T:chia.dotnet.DaemonProxy">
            <summary>
            <see cref="T:chia.dotnet.WebSocketRpcClient"/> for the daemon interface. The daemon can be used to proxy messages to and from other chia services.
            </summary>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.#ctor(chia.dotnet.WebSocketRpcClient,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.Exit(System.Threading.CancellationToken)">
            <summary>
            Tells the daemon at the RPC endpoint to exit.
            </summary>
            <remarks>There isn't a way to start the daemon remotely via RPC so take care that you have access to the RPC host if needed</remarks>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.IsServiceRunning(System.String,System.Threading.CancellationToken)">
            <summary>
            Determines if the named service is running
            </summary>
            <param name="service">The <see cref="T:chia.dotnet.ServiceNames"/> of the service</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/> with the boolean value indicating whether the service is running</returns>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.RegisterService(System.Threading.CancellationToken)">
            <summary>
            Registers this websocket to receive messages using <see cref="P:chia.dotnet.ServiceProxy.OriginService"/> This is needed to receive responses from services other than the daemon.
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.RegisterService(System.String,System.Threading.CancellationToken)">
            <summary>
            Registers this daemon to receive messages. This is needed to receive responses from services other than the daemon. 
            This is not a <see cref="T:chia.dotnet.ServiceNames"/> but usually the name of the consumer application such as 'wallet_ui'
            </summary>
            <param name="service">The name to register</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.StartService(System.String,System.Threading.CancellationToken)">
            <summary>
            Starts the named service
            </summary>
            <param name="service">The <see cref="T:chia.dotnet.ServiceNames"/> of the service</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DaemonProxy.StopService(System.String,System.Threading.CancellationToken)">
            <summary>
            Stops the named service
            </summary>
            <param name="service">The <see cref="T:chia.dotnet.ServiceNames"/> of the service</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.HttpClientExtensions">
            <summary>
            Extension methods to aid deserialization
            </summary>
        </member>
        <member name="M:chia.dotnet.HttpClientExtensions.Deserialize``1(System.Net.Http.HttpResponseMessage)">
            <summary>
            Helper method to deserialize content in a number of diferent ways
            </summary>
            <typeparam name="T"> The type to deserialize to
            <see cref="T:System.IO.Stream"/>
            <see cref="T:System.String"/>
            <see cref="T:System.Byte[]"/> array
            <see cref="T:System.Dynamic.ExpandoObject"/> when T is dynamic
            or other POCO types
            </typeparam>
            <param name="response">An <see cref="T:System.Net.Http.HttpResponseMessage"/> to deserialize</param>
            <returns>content deserialized to type T</returns>
        </member>
        <member name="T:chia.dotnet.DIDWallet">
            <summary>
            Wraps a Distributed Identity Wallet
            </summary>
        </member>
        <member name="M:chia.dotnet.DIDWallet.#ctor(System.UInt32,chia.dotnet.WalletProxy)">
            <summary>
            ctor
            </summary>
            <param name="walletId">The wallet_id to wrap</param>
            <param name="walletProxy">Wallet RPC proxy to use for communication</param>
        </member>
        <member name="M:chia.dotnet.DIDWallet.UpdateRecoveryIds(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Updates recovery ID's
            </summary>
            <param name="newList">The new ids</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.UpdateRecoveryIds(System.Collections.Generic.IEnumerable{System.String},System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Updates recovery ID's
            </summary>
            <param name="newList">The new ids</param>
            <param name="numVerificationsRequired">The number of verifications required</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.Spend(System.String,System.Threading.CancellationToken)">
            <summary>
            Spend from the DID wallet
            </summary>
            <param name="puzzlehash">The puzzlehash to spend</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.GetDID(System.Threading.CancellationToken)">
            <summary>
            Get the distributed identity and coin if present
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A DID and optional CoinID</returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.GetPubKey(System.Threading.CancellationToken)">
            <summary>
            Get the wallet pubkey
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The pubkey</returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.RecoverySpend(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Recovery spend
            </summary>
            <param name="attestFilenames">List of attest files. Must be >= num_of_backup_ids_needed</param>
            <param name="pubkey">The public key</param>
            <param name="puzzlehash">The puzzlehash of the spend</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.GetRecoveryList(System.Threading.CancellationToken)">
            <summary>
            Get the recover list
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The recover list and num required property of the wallet</returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.CreateAttest(System.String,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Create an attest file
            </summary>
            <param name="filename">file name of the attest</param>
            <param name="coinName">The coin name</param>
            <param name="pubkey">The public key</param>
            <param name="puzHash">The puzzlehash</param>        
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A spendbundle and information about the attest</returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.GetInformationNeededForRecovery(System.Threading.CancellationToken)">
            <summary>
            Create an attest file
            </summary>       
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A spendbundle and information about the attest</returns>
        </member>
        <member name="M:chia.dotnet.DIDWallet.CreateBackupFile(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Create a backup file of the wallet
            </summary>
            <param name="filename">The filename ot create</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.EndpointInfo">
            <summary>
            Information about how to connect and authenticate with the RPC endpoint
            </summary>
        </member>
        <member name="P:chia.dotnet.EndpointInfo.Uri">
            <summary>
            The secure websocket (wss) Uri of the RPC endpoint
            </summary>
        </member>
        <member name="P:chia.dotnet.EndpointInfo.CertPath">
            <summary>
            The full filesystem path to the public certificate used to authenticate with the Websocket (.crt)
            </summary>
        </member>
        <member name="P:chia.dotnet.EndpointInfo.KeyPath">
            <summary>
            The full filesystem path to the base64 encoded RSA private key to authneticate with the websocket (.key)
            </summary>
        </member>
        <member name="T:chia.dotnet.FarmerProxy">
            <summary>
            Proxy that communicates with the farmer via the daemon
            </summary>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.#ctor(chia.dotnet.IRpcClient,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.GetRewardTargets(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get the farm and pool reward targets 
            </summary>
            <param name="searchForPrivateKey">Include private key in search</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>the farm and pool reward targets</returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.SetRewardTargets(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Sets the farm and pool targets for the farmer
            </summary>
            <param name="farmerTarget">Farmer target</param>
            <param name="poolTarget">Pool target</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.GetSignagePoints(System.Threading.CancellationToken)">
            <summary>
            Get signage points
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>List of signage points</returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.GetSignagePoint(System.String,System.Threading.CancellationToken)">
            <summary>
            Get's a signage point by hash
            </summary>
            <param name="spHash">signage point hash</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a signage point and proofs of space</returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.GetHarvesters(System.Threading.CancellationToken)">
            <summary>
            Get the list of harvesters
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of harvesters</returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.GetPoolLoginLink(System.String,System.Threading.CancellationToken)">
            <summary>
            Get's the pool login link, if any
            </summary>
            <param name="launcherID">The id of the pool launcher</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The link</returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.GetPoolState(System.Threading.CancellationToken)">
            <summary>
            Get's the state of the pool
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of pool states</returns>
        </member>
        <member name="M:chia.dotnet.FarmerProxy.SetPayoutInstructions(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Set's a pool's payout instructions
            </summary>
            <param name="launcherID">The id of the pool launcher</param>
            <param name="payoutInstructions">The instructions</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.FullNodeProxy">
            <summary>
            Proxy that communicates with the full node via the daemon
            </summary>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.#ctor(chia.dotnet.IRpcClient,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetBlockchainState(System.Threading.CancellationToken)">
            <summary>
            Returns a summary of the node's view of the blockchain.
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>blockchain_state</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetBlock(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a block by a header hash
            </summary>
            <param name="headerhash">The header hash</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>block</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetBlockRecord(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a block record by a header hash
            </summary>
            <param name="headerhash">The header hash</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>block_record</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetBlockRecordByHeight(System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Retrieves a block record by height (assuming the height is less then or equal peak height)
            </summary>
            <param name="height">the height to get</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>block_record</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetBlockRecords(System.UInt32,System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Retrieves block records in a range
            </summary>        
            <param name="start">Start height</param>
            <param name="end">End Height - non-inclusive</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>list of block_record</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetBlocks(System.UInt32,System.UInt32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get the blocks between a start and end height
            </summary>
            <param name="start">Start height</param>
            <param name="end">End Height - non-inclusive</param>
            <param name="excludeHeaderhash">Flag indicating whether to include the header hash in the result or not</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of blocks</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetUnfinishedBlockHeaders(System.Threading.CancellationToken)">
            <summary>
            Get unfinished block headers
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of headers</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetCoinRecordsByPuzzleHash(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Retrieves the coins for a given puzzlehash, by default returns unspent coins.
            </summary>
            <param name="puzzlehash">The puzzle hash</param>
            <param name="includeSpendCoins">whether to include spent coins too, instead of just unspent</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of coin records</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetCoinRecordsByPuzzleHash(System.String,System.UInt32,System.UInt32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Retrieves the coins for a given puzzlehash, by default returns unspent coins.
            </summary>
            <param name="puzzlehash">The puzzle hash</param>
            <param name="startHeight">confirmation start height for search</param>
            <param name="endHeight">confirmation end height for search</param>
            <param name="includeSpendCoins">whether to include spent coins too, instead of just unspent</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of coin records</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetCoinRecordsByPuzzleHashes(System.Collections.Generic.IEnumerable{System.String},System.UInt32,System.UInt32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Retrieves the coins for a given list of puzzlehashes, by default returns unspent coins.
            </summary>
            <param name="puzzlehashes">The list of puzzle hashes</param>
            <param name="startHeight">confirmation start height for search</param>
            <param name="endHeight">confirmation end height for search</param>
            <param name="includeSpendCoins">whether to include spent coins too, instead of just unspent</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of coin records</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetCoinRecordByName(System.String,System.Threading.CancellationToken)">
            <summary>
            Retrieves a coin record by its name/id.
            </summary>
            <param name="name">The coin name</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A coin record</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetAdditionsAndRemovals(System.String,System.Threading.CancellationToken)">
            <summary>
            Retrieves the additions and removals (state transitions) for a certain block. Returns coin records for each addition and removal.
            </summary>
            <param name="headerhash">The header hash</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of additions and a list of removals</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetAllMempoolItems(System.Threading.CancellationToken)">
            <summary>
            Returns all items in the mempool.
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a list of mempool items</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetAllMemmpoolTxIds(System.Threading.CancellationToken)">
            <summary>
            Returns a list of all transaction IDs (spend bundle hashes) in the mempool.
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a list of tx_ids</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetMemmpooItemByTxId(System.String,System.Threading.CancellationToken)">
            <summary>
            Gets a mempool item by tx id.
            </summary>
            <param name="txId">Trasnaction id</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a list of tx_ids</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetNetworkSpace(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Retrieves an estimate of total space validating the chain between two block header hashes.
            </summary>
            <param name="newerBlockHeaderhash"></param>
            <param name="olderBlockHeaderhash"></param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns><see cref="T:System.Numerics.BigInteger"/> of network space in bytes</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetNetworkInfo(System.Threading.CancellationToken)">
            <summary>
            Retrieves information about the current network
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The network name and coin prefix</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.PushTx(System.Object,System.Threading.CancellationToken)">
            <summary>
            Pushes a transaction / spend bundle to the mempool and blockchain. 
            Returns whether the spend bundle was successfully included into the mempool
            </summary>
            <param name="spendBundle"></param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Indicator of whether the spend bundle was successfully included in the mempool</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetRecentSignagePoint(System.String,System.Threading.CancellationToken)">
            <summary>
            Gets a recent signage point
            </summary>
            <param name="spHash">signage point hash</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Indicator of whether the spend bundle was successfully included in the mempool</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetRecentEOS(System.String,System.Threading.CancellationToken)">
            <summary>
            Gets a recent end of slot
            </summary>
            <param name="challengeHash">challenge hash</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A signange _point or an eos</returns>
        </member>
        <member name="M:chia.dotnet.FullNodeProxy.GetPuzzleAndSolution(System.String,System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Gets a coin solution 
            </summary>
            <param name="coinId">Id of the coin</param>
            <param name="height">Block height</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A coin_solution</returns>
        </member>
        <member name="T:chia.dotnet.HarvesterProxy">
            <summary>
            Proxy that communicates with the harvester via the daemon
            </summary>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.#ctor(chia.dotnet.IRpcClient,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.GetPlots(System.Threading.CancellationToken)">
            <summary>
            Get the list of plot files
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of plots</returns>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.DeletePlot(System.String,System.Threading.CancellationToken)">
            <summary>
            Permanently delete a plot file
            </summary>
            <param name="filename">the file name of the plot</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
            <remarks><strong>Calling this DELETES the plot file. Proceed with caution.</strong></remarks>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.GetPlotDirectories(System.Threading.CancellationToken)">
            <summary>
            Get the list of plot directories from the harvester configuration
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>List of directories</returns>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.AddPlotDirectory(System.String,System.Threading.CancellationToken)">
            <summary>
            Add a plot directory to the harvester configuration
            </summary>
            <param name="dirname">The plot directory to add</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.RemovePlotDirectory(System.String,System.Threading.CancellationToken)">
            <summary>
            Removes a plot directory from the harveser configuration
            </summary>
            <param name="dirname">The directory to remove</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.HarvesterProxy.RefreshPlots(System.Threading.CancellationToken)">
            <summary>
            Refresh the list of plots
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.HttpRpcClient">
            <summary>
            Base class that handles core communication with the rpc endpoint using http(s)
            and synchronizes request and response messages
            </summary>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.#ctor(chia.dotnet.EndpointInfo)">
            <summary>
            ctor
            </summary>
            <param name="endpoint">Details of the websocket endpoint</param>        
        </member>
        <member name="P:chia.dotnet.HttpRpcClient.Endpoint">
            <summary>
            Details of the RPC service endpoint
            </summary>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.Connect(System.Threading.CancellationToken)">
            <summary>
            Opens the websocket and starts the receive loop
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable Task</returns>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.OnConnected">
            <summary>
            Called after <see cref="M:chia.dotnet.HttpRpcClient.Connect(System.Threading.CancellationToken)"/> completes successfully. Lets derived classess know that they can do
            post connection initialization 
            </summary>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.Close(System.Threading.CancellationToken)">
            <summary>
            Cancels the receive loop and closes the websocket
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.PostMessage(chia.dotnet.Message,System.Threading.CancellationToken)">
            <summary>
            Posts a <see cref="T:chia.dotnet.Message"/> to the websocket but does not wait for a response
            </summary>
            <param name="message">The message to send</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <remarks>Awaiting this method waits for the message to be sent only. It doesn't await a response.</remarks>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.SendMessage(chia.dotnet.Message,System.Threading.CancellationToken)">
            <summary>
            Sends a <see cref="T:chia.dotnet.Message"/> to the websocket and waits for a response
            </summary>
            <param name="message">The message to send</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <remarks>Awaiting this method will block until a response is received from the rpc endpoint or the <see cref="T:System.Threading.CancellationToken"/> is cancelled</remarks>
            <returns>The response message</returns>
            <exception cref="T:chia.dotnet.ResponseException">Throws when <see cref="P:chia.dotnet.Message.IsSuccessfulResponse"/> is False</exception>
        </member>
        <member name="E:chia.dotnet.HttpRpcClient.BroadcastMessageReceived">
            <summary>
            Event raised when a message is received from the endpoint that was either not in response to a request
            or was a response from a posted message (i.e. we didn't register to receive the response)
            Pooling state_changed messages come through this event
            </summary>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.OnBroadcastMessageReceived(chia.dotnet.Message)">
            <summary>
            Raises the <see cref="E:chia.dotnet.HttpRpcClient.BroadcastMessageReceived"/> event
            </summary>
            <param name="message">The message to broadcast</param>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.Dispose(System.Boolean)">
            <summary>
            Called when the instance is being disposed or finalized
            </summary>
            <param name="disposing">Invoke from <see cref="M:System.IDisposable.Dispose"/></param>
        </member>
        <member name="M:chia.dotnet.HttpRpcClient.Dispose">
            <summary>
            <see cref="M:System.IDisposable.Dispose"/>
            </summary>
        </member>
        <member name="T:chia.dotnet.IRpcClient">
            <summary>
            Interface representing prc communcation
            </summary>
        </member>
        <member name="P:chia.dotnet.IRpcClient.Endpoint">
            <summary>
            Details of the RPC service endpoint
            </summary>
        </member>
        <member name="E:chia.dotnet.IRpcClient.BroadcastMessageReceived">
            <summary>
            Event raised when a message is received from the endpoint that was either not in response to a request
            or was a response from a posted message (i.e. we didn't register to receive the response)
            Pooling state_changed messages come through this event
            </summary>
        </member>
        <member name="M:chia.dotnet.IRpcClient.Close(System.Threading.CancellationToken)">
            <summary>
            Cancels the receive loop and closes the websocket
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.IRpcClient.Connect(System.Threading.CancellationToken)">
            <summary>
            Called after <see cref="M:chia.dotnet.IRpcClient.Connect(System.Threading.CancellationToken)"/> completes successfully. Lets derived classess know that they can do
            post connection initialization 
            </summary>
        </member>
        <member name="M:chia.dotnet.IRpcClient.PostMessage(chia.dotnet.Message,System.Threading.CancellationToken)">
            <summary>
            Posts a <see cref="T:chia.dotnet.Message"/> to the websocket but does not wait for a response
            </summary>
            <param name="message">The message to post</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <remarks>Awaiting this method waits for the message to be sent only. It doesn't await a response.</remarks>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.IRpcClient.SendMessage(chia.dotnet.Message,System.Threading.CancellationToken)">
            <summary>
            Sends a <see cref="T:chia.dotnet.Message"/> to the endpoint and waits for a response
            </summary>
            <param name="message">The message to send</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <remarks>Awaiting this method will block until a response is received from the <see cref="P:chia.dotnet.IRpcClient.Endpoint"/> or the <see cref="T:System.Threading.CancellationToken"/> is cancelled</remarks>
            <returns>The response message</returns>
            <exception cref="T:chia.dotnet.ResponseException">Throws when <see cref="P:chia.dotnet.Message.IsSuccessfulResponse"/> is False</exception>
        </member>
        <member name="T:chia.dotnet.Message">
            <summary>
            The messaging data structure for request and response exchange with the RPC endpoint
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.Command">
            <summary>
            The command to be processed by the endpoint service
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.Data">
            <summary>
            Data to go along with the command
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.Origin">
            <summary>
            The name of the origin service
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.Destination">
            <summary>
            The name of the destination service
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.Ack">
            <summary>
            Indication whether message is an acknowledgement (i.e response)
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.RequestId">
            <summary>
            Unique correlation id of the message. This will round trip to the RPC server and back in its response
            </summary>
        </member>
        <member name="P:chia.dotnet.Message.IsSuccessfulResponse">
            <summary>
            Inidcates whether this is a response (<see cref="P:chia.dotnet.Message.Ack"/> is true) and the success flag is also true
            </summary>
        </member>
        <member name="M:chia.dotnet.Message.Create(System.String,System.Object,System.String,System.String)">
            <summary>
            Construct a new instance of a <see cref="T:chia.dotnet.Message"/>
            </summary>
            <param name="command"><see cref="P:chia.dotnet.Message.Command"/></param>
            <param name="data"><see cref="P:chia.dotnet.Message.Data"/></param>
            <param name="destination"><see cref="P:chia.dotnet.Message.Destination"/></param>
            <param name="origin"><see cref="P:chia.dotnet.Message.Origin"/></param>
            <returns>A populated <see cref="T:chia.dotnet.Message"/></returns>
            <remarks>Ensure that <see cref="P:chia.dotnet.Message.Data"/> and <see cref="P:chia.dotnet.Message.RequestId"/> are set appropriately</remarks>
        </member>
        <member name="M:chia.dotnet.Message.ToJson">
            <summary>
            Serialize the <see cref="T:chia.dotnet.Message"/> to a json string
            </summary>
            <returns>Json representation of the message</returns>
        </member>
        <member name="M:chia.dotnet.Message.FromJson(System.String)">
            <summary>
            Deserialize a <see cref="T:chia.dotnet.Message"/> from a json string
            </summary>
            <param name="json">Json representation of the Message</param>
            <returns><see cref="T:chia.dotnet.Message"/></returns>
        </member>
        <member name="T:chia.dotnet.KValues">
            <summary>
            Valid plot sizes
            </summary>
        </member>
        <member name="T:chia.dotnet.PlotterConfig">
            <summary>
            Configuration settings for the plotter. (equivalent to chia plots create command line args)
            </summary>
        </member>
        <member name="T:chia.dotnet.PlotterProxy">
            <summary>
            Class to manage plotting
            </summary>
        </member>
        <member name="M:chia.dotnet.PlotterProxy.#ctor(chia.dotnet.WebSocketRpcClient,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>
        </member>
        <member name="M:chia.dotnet.PlotterProxy.RegisterPlotter(System.Threading.CancellationToken)">
            <summary>
            Registers this instance as a plotter and retreives the plot queue
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The plot queue</returns>
        </member>
        <member name="M:chia.dotnet.PlotterProxy.StartPlotting(chia.dotnet.PlotterConfig,System.Threading.CancellationToken)">
            <summary>
            Starts plotting. Returns after plot is added to the plotting queue. Does not wiat for plot to finish
            </summary>
            <param name="config">The config of the plot. Maps 1:1 to the chia plot create command line</param>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.PlotterProxy.StopPlotting(System.String,System.Threading.CancellationToken)">
            <summary>
            Stops the plot with the given id
            </summary>
            <param name="id">The id of the plot to stop. Can be found by inspecting the plot queue returned from <see cref="M:chia.dotnet.PlotterProxy.RegisterPlotter(System.Threading.CancellationToken)"/></param>
            <param name="cancellationToken"></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.PoolWallet">
            <summary>
            Wraps a Pool Wallet
            </summary>
        </member>
        <member name="M:chia.dotnet.PoolWallet.#ctor(System.UInt32,chia.dotnet.WalletProxy)">
            <summary>
            ctor
            </summary>
            <param name="walletId">The wallet_id to wrap</param>
            <param name="walletProxy">Wallet RPC proxy to use for communication</param>
        </member>
        <member name="M:chia.dotnet.PoolWallet.JoinPool(System.String,System.String,System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Join the wallet to a pool
            </summary>
            <param name="targetPuzzlehash">Puzzle hash</param>
            <param name="poolUrl">Url of the pool to join</param>
            <param name="relativeLockHeight">Relative lock height</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A transaction</returns>
        </member>
        <member name="M:chia.dotnet.PoolWallet.SelfPool(System.Threading.CancellationToken)">
            <summary>
            Leaving a pool requires two state transitions.
            First we transition to PoolSingletonState.LEAVING_POOL
            Then we transition to FARMING_TO_POOL or SELF_POOLING
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A transaction</returns>
        </member>
        <member name="M:chia.dotnet.PoolWallet.AbsorbRewards(System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Perform a sweep of the p2_singleton rewards controlled by the pool wallet singleton
            </summary>
            <param name="fee">Transaction fee (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Wallet state and transaction</returns>
        </member>
        <member name="M:chia.dotnet.PoolWallet.Status(System.Threading.CancellationToken)">
            <summary>
            Perform a sweep of the p2_singleton rewards controlled by the pool wallet singleton
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Wallet state and list of unconfirmed transactions</returns>
        </member>
        <member name="T:chia.dotnet.RateLimitedWallet">
            <summary>
            Wraps a Coloured Coin wallet
            </summary>
        </member>
        <member name="M:chia.dotnet.RateLimitedWallet.#ctor(System.UInt32,chia.dotnet.WalletProxy)">
            <summary>
            ctor
            </summary>
            <param name="walletId">The wallet_id to wrap</param>
            <param name="walletProxy">Wallet RPC proxy to use for communication</param>
        </member>
        <member name="M:chia.dotnet.RateLimitedWallet.SetUserInfo(System.Numerics.BigInteger,System.Numerics.BigInteger,System.ValueTuple{System.String,System.String,System.Numerics.BigInteger},System.String,System.Threading.CancellationToken)">
            <summary>
            Sets user info for the wallet
            </summary>
            <param name="interval">The limit interval</param>
            <param name="limit">The limit amount</param>
            <param name="origin">Origin infomration about the wallet</param> 
            <param name="adminPubkey">The wallet admin pubkey</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.RateLimitedWallet.SendClawbackTransaction(System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Sends a clawback transaction
            </summary>
            <param name="fee">Fee amount (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the transaction</returns>
        </member>
        <member name="M:chia.dotnet.RateLimitedWallet.AddFunds(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Add rate limited funds to the wallet
            </summary>
            <param name="amount">The amount to add (in units of mojos)</param>
            <param name="fee">Transaction fee (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.ResponseException">
            <summary>
            Exception thrown when the RPC endpoint returns a response <see cref="T:chia.dotnet.Message"/> but Data.success is false
            </summary>
        </member>
        <member name="M:chia.dotnet.ResponseException.#ctor(chia.dotnet.Message)">
            <summary>
            ctor
            </summary>
            <param name="request">The request sent to the service</param>
        </member>
        <member name="M:chia.dotnet.ResponseException.#ctor(chia.dotnet.Message,System.String)">
            <summary>
            ctor
            </summary>
            <param name="request">The request sent to the service</param>
            <param name="message"><see cref="P:System.Exception.Message"/></param>
        </member>
        <member name="M:chia.dotnet.ResponseException.#ctor(chia.dotnet.Message,System.String,System.Exception)">
            <summary>
            ctor
            </summary>
            <param name="request">The request sent to the service</param>
            <param name="message"><see cref="P:System.Exception.Message"/></param>
            <param name="innerException"><see cref="P:System.Exception.InnerException"/></param>
        </member>
        <member name="P:chia.dotnet.ResponseException.Request">
            <summary>
            The request sent to the service
            </summary>
        </member>
        <member name="T:chia.dotnet.ServiceProxy">
            <summary>
            Base class that uses a <see cref="P:chia.dotnet.ServiceProxy.RpcClient"/> to send and receive messages to other services
            </summary>
            <remarks>The lifetime of the RpcClient is not controlled by the proxy. It should be disposed outside of this class. <see cref="M:chia.dotnet.IRpcClient.Connect(System.Threading.CancellationToken)"/></remarks>
        </member>
        <member name="M:chia.dotnet.ServiceProxy.#ctor(chia.dotnet.IRpcClient,System.String,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="destinationService"><see cref="P:chia.dotnet.Message.Destination"/></param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>        
        </member>
        <member name="P:chia.dotnet.ServiceProxy.OriginService">
            <summary>
            The name of the service that is running. Will be used as the <see cref="P:chia.dotnet.Message.Origin"/> of all messages
            as well as the identifier used for <see cref="M:chia.dotnet.DaemonProxy.RegisterService(System.String,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:chia.dotnet.ServiceProxy.DestinationService">
            <summary>
            <see cref="P:chia.dotnet.Message.Destination"/>
            </summary>
        </member>
        <member name="P:chia.dotnet.ServiceProxy.RpcClient">
            <summary>
            The <see cref="P:chia.dotnet.ServiceProxy.RpcClient"/> used for underlying RPC
            </summary>
        </member>
        <member name="M:chia.dotnet.ServiceProxy.Ping(System.Threading.CancellationToken)">
            <summary>
            Sends ping message to the service
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.ServiceProxy.StopNode(System.Threading.CancellationToken)">
            <summary>
            Stops the node
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.ServiceProxy.GetConnections(System.Threading.CancellationToken)">
            <summary>
            Get connections that the service has
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of connections</returns>
        </member>
        <member name="M:chia.dotnet.ServiceProxy.OpenConnection(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Add a connection
            </summary>
            <param name="host">The host name of the connection</param>
            <param name="port">The port to use</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.ServiceProxy.CloseConnection(System.String,System.Threading.CancellationToken)">
            <summary>
            Closes a connection
            </summary>
            <param name="nodeId">The id of the node to close</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="T:chia.dotnet.Wallet">
            <summary>
            Base class representing a specific wallet (i.e. anything with a WalletID)
            </summary>
        </member>
        <member name="M:chia.dotnet.Wallet.#ctor(System.UInt32,chia.dotnet.WalletProxy)">
            <summary>
            ctor
            </summary>
            <param name="walletId">The wallet_id to wrap</param>
            <param name="walletProxy">Wallet RPC proxy to use for communication</param>
        </member>
        <member name="P:chia.dotnet.Wallet.WalletId">
            <summary>
            The id of the wallet
            </summary>
        </member>
        <member name="P:chia.dotnet.Wallet.WalletProxy">
            <summary>
            Wallet RPC proxy for communication
            </summary>
        </member>
        <member name="M:chia.dotnet.Wallet.Login(System.Threading.CancellationToken)">
            <summary>
            Login to the wallet
            </summary>
            <remarks>Always login before interacting with the wallet. Logged in state is kept on the serve so might have changed</remarks>
            <returns>an awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.Wallet.GetBalance(System.Threading.CancellationToken)">
            <summary>
            Get the balance of a specific wallet
            </summary>      
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The wallet balance (in units of mojos)</returns>
        </member>
        <member name="M:chia.dotnet.Wallet.GetTransactions(System.Threading.CancellationToken)">
            <summary>
            Get the list of transactions
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of transactions</returns>
        </member>
        <member name="M:chia.dotnet.Wallet.GetNextAddress(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get the last address or create a new one
            </summary>
            <param name="newAddress">Whether to generate a new address</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An address</returns>
        </member>
        <member name="M:chia.dotnet.Wallet.GetTransactionCount(System.Threading.CancellationToken)">
            <summary>
            Get the number of transactions
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The number of transactions</returns>
        </member>
        <member name="M:chia.dotnet.Wallet.DeleteUnconfirmedTransactions(System.Threading.CancellationToken)">
            <summary>
            Delete unconfirmed transactions from the wallet
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.Wallet.SendTransaction(System.String,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Sends a transaction
            </summary>
            <param name="address">The receiving address</param>
            <param name="amount">The amount to send (in units of mojos)</param>
            <param name="fee">Fee amount (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The transaction</returns>
        </member>
        <member name="M:chia.dotnet.Wallet.SendTransactionMulti(System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object},System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Sends a transaction
            </summary>
            <param name="additions">Additions to the block chain</param>
            <param name="coins">Coins to include</param>
            <param name="fee">Fee amount (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The transaction</returns>
        </member>
        <member name="M:chia.dotnet.Wallet.SendTransactionMulti(System.Collections.Generic.IEnumerable{System.Object},System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Sends a transaction
            </summary>
            <param name="additions">Additions to the block chain</param>
            <param name="fee">Fee amount (in units of mojo)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The transaction</returns>
        </member>
        <member name="T:chia.dotnet.WalletProxy">
            <summary>
            Proxy that communicates with the wallet via the daemon
            </summary>
        </member>
        <member name="F:chia.dotnet.WalletProxy.DefaultBackupHost">
            <summary>
            Default location for backups
            </summary>
        </member>
        <member name="M:chia.dotnet.WalletProxy.#ctor(chia.dotnet.IRpcClient,System.String)">
            <summary>
            ctor
            </summary>
            <param name="rpcClient"><see cref="T:chia.dotnet.IRpcClient"/> instance to use for rpc communication</param>
            <param name="originService"><see cref="P:chia.dotnet.Message.Origin"/></param>
        </member>
        <member name="M:chia.dotnet.WalletProxy.LogIn(System.UInt32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Sets a key to active.
            </summary>
            <param name="fingerprint">The fingerprint</param>          
            <param name="skipImport">Indicator whether to skip the import at login</param>          
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a key fingerprint</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.LogInAndRestoreBackup(System.UInt32,System.String,System.Threading.CancellationToken)">
            <summary>
            Sets a key to active.
            </summary>
            <param name="fingerprint">The fingerprint</param>
            <param name="filePath">The path to the backup file</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a key fingerprint</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetWallets(System.Threading.CancellationToken)">
            <summary>
            Get the list of wallets
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A list of wallets</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetPublicKeys(System.Threading.CancellationToken)">
            <summary>
            Get all root public keys accessible by the wallet
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>all root public keys accessible by the walle</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetPrivateKey(System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Get the private key accessible by the wallet
            </summary>
            <param name="fingerprint">The fingerprint</param>          
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a private key</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetSyncStatus(System.Threading.CancellationToken)">
            <summary>
            Get the wallet's sync status
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>sync status</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetNetworkInfo(System.Threading.CancellationToken)">
            <summary>
            Retrieves information about the current network
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>network name and prefix</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetHeightInfo(System.Threading.CancellationToken)">
            <summary>
            Get blockchain height info
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Current block height</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetTransaction(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a specific transaction
            </summary>
            <param name="transactionId">The id of the transaction to find</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>A transaction</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateBackup(System.String,System.Threading.CancellationToken)">
            <summary>
            Backup the wallet
            </summary>
            <param name="filePath">Path to the backup file to create</param> 
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.AddKey(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Deletes a specific key from the wallet
            </summary>        
            <param name="mnemonic">The key mnemonic</param>
            <param name="skipImport">Indicator whether to skip the import at login</param>                
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The new key's fingerprint</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.AddKeyAndRestoreBackup(System.UInt32,System.String,System.Threading.CancellationToken)">
            <summary>
            Add a new key and restores from backup
            </summary>
            <param name="fingerprint">The fingerprint</param>
            <param name="filePath">The path to the backup file</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>a key fingerprint</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.DeleteKey(System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Deletes a specific key from the wallet
            </summary>        
            <param name="fingerprint">The key's fingerprint</param>  
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CheckDeleteKey(System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Check the key use prior to possible deletion
            checks whether key is used for either farm or pool rewards
            checks if any wallets have a non-zero balance
            </summary>        
            <param name="fingerprint">The key's fingerprint</param>  
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>
            idicators of how wallet is used
            </returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.DeleteAllKeys(System.Threading.CancellationToken)">
            <summary>
            Deletes all keys from the wallet
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GenerateMnemonic(System.Threading.CancellationToken)">
            <summary>
            Generates a new mnemonic phrase
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The new mnemonic as an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of 24 words</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateColourCoinWallet(System.Numerics.BigInteger,System.Numerics.BigInteger,System.String,System.Threading.CancellationToken)">
            <summary>
            Create a new colour coin wallet
            </summary>
            <param name="amount">the amount to put in the wallet (in units of mojos)</param>
            <param name="fee">fee to create the wallet (in units of mojos)</param>
            <param name="colour">The coin Colour</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateColouredCoinForColour(System.String,System.Threading.CancellationToken)">
            <summary>
            Create a coloured coin wallet for an existing colour
            </summary>
            <param name="colour">The coin Colour</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>        
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateRateLimitedAdminWallet(System.String,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Creates a new Admin Rate Limited wallet
            </summary>
            <param name="pubkey">admin pubkey</param>
            <param name="interval">The limit interval</param>
            <param name="limit">The limit amount</param>
            <param name="amount">the amount to put in the wallet (in units of mojos)</param>     
            <param name="fee">fee to create the wallet (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateRateLimitedUserWallet(System.Threading.CancellationToken)">
            <summary>
            Creates a new User Rate Limited wallet
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateDIDWallet(System.Collections.Generic.IEnumerable{System.String},System.Numerics.BigInteger,System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Creates a new DID wallet
            </summary>
            <param name="backupDIDs">Backup DIDs</param>
            <param name="numOfBackupIdsNeeded">The number of back ids needed to create the wallet</param>
            <param name="amount">the amount to put in the wallet (in units of mojos)</param>           
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.RecoverDIDWallet(System.String,System.Threading.CancellationToken)">
            <summary>
            Recover a DID wallet
            </summary>
            <param name="filename">Filename to recover from</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreatePoolWallet(System.Object,System.Numerics.BigInteger,System.String,System.Threading.CancellationToken)">
            <summary>
            Creates a new pool wallet
            </summary>
            <param name="initialTargetState">The desired intiial state of the wallet</param>
            <param name="p2SingletonDelayedPH">A delayed address (can be null or empty to not use)</param>
            <param name="p2SingletonDelayTime">Delay time to create the wallet</param>           
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Information about the wallet</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateOfferForIds(System.Collections.Generic.IDictionary{System.Int32,System.Int32},System.String,System.Threading.CancellationToken)">
            <summary>
            Create an offer file from a set of id's
            </summary>
            <param name="ids">The set of ids</param>
            <param name="filename">path to the offer file to create</param>   
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetDiscrepenciesForOffer(System.String,System.Threading.CancellationToken)">
            <summary>
            Get offer discrepencies
            </summary>
            <param name="filename">path to the offer file</param>         
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The dicrepencies</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.RespondToOffer(System.String,System.Threading.CancellationToken)">
            <summary>
            Respond to an offer
            </summary>
            <param name="filename">path to the offer file</param>        
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetTrade(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a trade
            </summary>
            <param name="tradeId">The id of the trade to find</param>         
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The trade</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetAllTrades(System.Threading.CancellationToken)">
            <summary>
            Get all trades
            </summary>        
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The trades</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CancelTrade(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Cancel a trade
            </summary>
            <param name="tradeId">The id of the trade to find</param>         
            <param name="secure">Flag indicating whether to cancel pedning offer securely or not</param>         
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>An awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.GetFarmedAmount(System.Threading.CancellationToken)">
            <summary>
            Get the amount farmed
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The amount farmed</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateSignedTransaction(System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object},System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Create but do not send a transaction
            </summary>
            <param name="additions">Additions to the block chain</param>
            <param name="coins">Coins to include</param>
            <param name="fee">Fee amount (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:chia.dotnet.WalletProxy.CreateSignedTransaction(System.Collections.Generic.IEnumerable{System.Object},System.Numerics.BigInteger,System.Threading.CancellationToken)">
            <summary>
            Create but do not send a transaction
            </summary>
            <param name="additions">Additions to the block chain</param>
            <param name="fee">Fee amount (in units of mojos)</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>The signed transaction</returns>
        </member>
        <member name="T:chia.dotnet.WebSocketRpcClient">
            <summary>
            Base class that handles core websocket communication with the rpc endpoint
            and synchronizes request and response messages
            </summary>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.#ctor(chia.dotnet.EndpointInfo)">
            <summary>
            ctor
            </summary>
            <param name="endpoint">Details of the websocket endpoint</param>        
        </member>
        <member name="P:chia.dotnet.WebSocketRpcClient.Endpoint">
            <summary>
            Details of the RPC service endpoint
            </summary>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.Connect(System.Threading.CancellationToken)">
            <summary>
            Opens the websocket and starts the receive loop
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable Task</returns>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.OnConnected">
            <summary>
            Called after <see cref="M:chia.dotnet.WebSocketRpcClient.Connect(System.Threading.CancellationToken)"/> completes successfully. Lets derived classess know that they can do
            post connection initialization 
            </summary>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.Close(System.Threading.CancellationToken)">
            <summary>
            Cancels the receive loop and closes the websocket
            </summary>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.PostMessage(chia.dotnet.Message,System.Threading.CancellationToken)">
            <summary>
            Posts a <see cref="T:chia.dotnet.Message"/> to the websocket but does not wait for a response
            </summary>
            <param name="message">The message to post</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <remarks>Awaiting this method waits for the message to be sent only. It doesn't await a response.</remarks>
            <returns>Awaitable <see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.SendMessage(chia.dotnet.Message,System.Threading.CancellationToken)">
            <summary>
            Sends a <see cref="T:chia.dotnet.Message"/> to the endpoint and waits for a response
            </summary>
            <param name="message">The message to send</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/></param>
            <remarks>Awaiting this method will block until a response is received from the <see cref="T:System.Net.WebSockets.WebSocket"/> or the <see cref="T:System.Threading.CancellationToken"/> is cancelled</remarks>
            <returns>The response message</returns>
            <exception cref="T:chia.dotnet.ResponseException">Throws when <see cref="P:chia.dotnet.Message.IsSuccessfulResponse"/> is False</exception>
        </member>
        <member name="E:chia.dotnet.WebSocketRpcClient.BroadcastMessageReceived">
            <summary>
            Event raised when a message is received from the endpoint that was either not in response to a request
            or was a response from a posted message (i.e. we didn't register to receive the response)
            Pooling state_changed messages come through this event
            </summary>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.OnBroadcastMessageReceived(chia.dotnet.Message)">
            <summary>
            Raises the <see cref="E:chia.dotnet.WebSocketRpcClient.BroadcastMessageReceived"/> event
            </summary>
            <param name="message">The message to broadcast</param>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.Dispose(System.Boolean)">
            <summary>
            Called when the instance is being disposed or finalized
            </summary>
            <param name="disposing">Invoke from <see cref="M:System.IDisposable.Dispose"/></param>
        </member>
        <member name="M:chia.dotnet.WebSocketRpcClient.Dispose">
            <summary>
            <see cref="M:System.IDisposable.Dispose"/>
            </summary>
        </member>
    </members>
</doc>
